# PolyLadder — Development Rules

---

## 1. Project Overview

PolyLadder is a cloud-hosted web application for parallel language learning.
The system consists of four subsystems:
- Data Governance Core
- Content Refinement Service
- Operational UI
- Learning Application

All development follows feature specifications in `docs/features/`.

---

## 2. Git Workflow (STRICT)

### Branches
- `main` is always stable and deployable
- Each feature gets its own branch: `feature/FXXX-short-name`
- Branch from `main`, merge back to `main`

### Commits
- One task = one commit
- Commit message format: `feat(FXXX): task description`
- Examples:
  - `feat(F000): initialize monorepo structure`
  - `feat(F001): create users table migration`
  - `test(F007): add lifecycle validator tests`

### Pull Requests
- One feature = one PR
- PR title: `feat: FXXX - Feature Name`
- PR must pass CI before merge
- No merges without approval

---

## 3. CI/CD (GitHub Actions)

Add GitHub Actions as soon as there is code to validate:
- After F000: lint, typecheck, build
- After F001: database migrations test
- After first tests: test runner
- After API: integration tests
- After UI: E2E tests with Playwright

CI must pass before PR can be merged.

---

## 4. Work Discipline

- Follow feature specs in `docs/features/FXXX-*.md`
- One feature at a time
- One task at a time within feature
- Plan → Implement → Test → Commit → Next task

No parallel work on multiple features.

---

## 5. Code Quality (STRICT)

### Clean Code
- Self-descriptive code
- Small functions (max 20-30 lines)
- Clear naming
- No hidden behavior

### Architecture
- Follow package structure from ARCHITECTURE.md
- Clear separation between packages
- No circular dependencies

### TypeScript
- Strict mode enabled
- No `any` types
- Explicit return types on public functions

---

## 6. Comments Policy

### PROHIBITED
- Comments explaining obvious code
- Inline comments for simple operations
- TODO comments (use GitHub issues instead)

### ALLOWED
- JSDoc for public API functions
- Complex algorithm explanations (rare)
- Tests: `// Arrange`, `// Act`, `// Assert`

If code needs comments to be understood → refactor.

---

## 7. Testing Rules

### Unit Tests
- All business logic must be unit tested
- Tests live in `tests/` folder of each package
- Use Vitest
- Test naming: `describe('ModuleName')`, `it('should do X when Y')`
- No skipped tests in main branch

### Integration Tests (MANDATORY for API features)
- All API endpoints MUST have integration tests
- Integration tests live in `packages/api/tests/integration/`
- Tests must cover: success cases, error cases, auth requirements
- Use `server.inject()` for HTTP testing
- Clean database between tests with `cleanupTestData()`
- Run with: `pnpm --filter @polyladder/api test:integration`

### E2E Tests (MANDATORY for UI features)
- All UI features MUST have E2E tests with Playwright
- E2E tests live in `packages/web/e2e/`
- Tests must cover: user flows, edge cases, cross-browser compatibility
- Use Playwright for browser automation
- Test naming: `test('should do X when user does Y')`
- Tests must be runnable in headless mode for CI
- Run with: `pnpm --filter @polyladder/web test:e2e`
- Include visual regression tests where appropriate

---

## 8. Feature Implementation Flow

1. Create branch: `git checkout -b feature/FXXX-name`
2. Read feature spec: `docs/features/FXXX-*.md`
3. For each task in spec:
   - Implement
   - Test (unit + integration for API, unit + E2E for UI)
   - Commit with message `feat(FXXX): task description`
4. Push branch
5. Create PR
6. Wait for CI (lint, typecheck, unit, integration, E2E)
7. Request review
8. Merge after approval

---

## 9. AI Assistant Guidelines

You ARE allowed to:
- Choose implementation patterns within spec
- Propose improvements to specs
- Make technical decisions not covered by spec

You are NOT allowed to:
- Skip tasks or take shortcuts
- Change product scope
- Merge without human approval
- Disable or skip tests

---

End of Development Rules
